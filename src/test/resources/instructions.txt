Przypadki do sprawdzenia



Zaleznosc pomiedyz polami
1. Pole A jest wymagane tylko wtedy, gdy pole B jest uzupelnione
2. Pole A jest wymagane tylko wtedy, gdy pole B jest uzupelnione i pole C jest puste
3. Określenie warunków visible + required (jako niezalezne lub zalezne - proba unifikacji)
4.

Walidatory
0. Sposob ustawiania walidatora
1. Ustawianie walidatora jako domyślnego
2. Ustawianie wartosci innego walidatora jako wplywajacego na inny walidator
3. Walidatory jako aktywne lub okreslane za pomoca add/remove/replace
3.1 Parametryzacja walidatorow (np. min/max)
4. Wiele "caseów" ustawiania walidatora na podstawie kilku warunkow (wzglednienie operatorow or/and itp.)
5. Regexy dla walidatorow
6. Walidatory funkcyjne/predykaty - FE
7. Walidatory funkcyjne/predykaty - BE
8. Parametryzacja walidatorów predykatow
9. Walidaor jako sterowanie disable/enable (nie tylko wartosc)


Typowe błędy logiczne i linterowe

    visible = false, required = true → sprzeczność.

    fieldY.options bez defaultValue → puste dropdowny.

    Brak defaultValue → computedRules nie deterministyczne.

    Brak .endField() lub pola bez walidatora → niepełna definicja pola.


Strukturalne podejścia do DSL (które warto przetestować)

    Czy można zagnieżdżać Condition.and(...) i Condition.or(...) dowolnie głęboko?

    Czy valueWhen(...) obsługuje wiele reguł? Jak traktujesz pierwsze spełnione?

    Czy walidatory obsługują group(XOR)? Co jeśli dwie reguły się spełnią?

    Czy derivedValue może odnosić się do pola grupowego (np. address.birthYear)?

    Czy .validator(...) może wystąpić bez .activeWhen(...)? (czy to zawsze true?)

Propozycja: checklist dla DSL/testów

    Każde pole ma visible, required, editable, label z defaultem

    Każdy walidator ma activeWhen, value, defaultValue

    Złożone warunki (AND, OR, XOR) mają fallback

    Nie ma kolizji required && !visible

    Walidatory funkcyjne są jawnie oznaczone jako FE lub BE

    field.defaultValue logicznie spójne z field.type

    Brak reguł wpływających poza own field.property


Określenie zapisu:
Podejscie deklaratywne:
✅ Czytelność i jednoznaczność	Biznes, analityk i developer widzą co, kiedy i jak działa
✅ Deterministyczność	FE/BE zawsze wie, jaka wartość ma obowiązywać — bez if/else rozrzuconego po kodzie
✅ Testowalność	Można pisać testy per reguła, trace’ować aktywne ścieżki, porównywać computedRules
✅ Linter-friendly	Możesz sprawdzić: brak fallbacku, kolizje, sprzeczne wymagania (required && !visible)
✅ Eksportowalność	Łatwo wygenerować computedRules do FE, dokumentację, debug view
✅ Skalowalność	Nawet setki pól i reguł są łatwe do utrzymania – bo są zorganizowane per pole i property
✅ Brak efektów ubocznych	Każda reguła działa lokalnie – nie mutuje innych pól w ukryciu

❌ Więcej formalizmu na starcie	Trzeba stworzyć własny model Condition, ValueRule, FieldLogic
❌ Mniej elastyczne przy akcjach imperatywnych	ScrollTo, trackEvent, itp. wymagają osobnego mechanizmu
❌ Trudniej wyrazić akcje proceduralne	Np. jeśli A i B → pokaż C i przejdź do kroku 4 wymaga dodatkowej warstwy
❌ Potrzeba lintera i walidatora	Jeśli tego nie ma – rośnie ryzyko kolizji i nieczytelności (choć mniejsze niż przy imperatywnym)
❌ Wiecej duplikacji  -  Trzeba powtarzać reguły dla różnych walidatorów, bo nie można ich łączyć
❌ Mniej czytelne


Impretatywne:
✅ Elastyczność i natychmiastowa kontrola	Możesz wykonać dowolny efekt, dowolny kod, użyć if, switch, itd.
✅ Niższy próg wejścia	Deweloper po prostu pisze if/else jak zawsze
✅ Wygodne do dynamicznych, nieregularnych akcji	Obsługa trackEvent, gotoStep, scrollTo, itp. może być naturalniejsza imperatywnie
✅ Bezpośrednia integracja z kodem aplikacji	Można łatwo wołać zależności, serwisy, async efekty

❌ Logika porozrzucana po kodzie	Nie da się spojrzeć na jedno pole i zrozumieć, kiedy i dlaczego jest widoczne/wymagane
❌ Brak deterministycznego runtime	field.visible = x może być nadpisywane wielokrotnie w różnych miejscach
❌ Brak struktury = chaos rośnie wykładniczo	Każdy if/else to potencjalny bug, kolizja, wymagający test ręczny
❌ Brak możliwości automatycznego lintowania	Nie wykryjesz required && !visible, nie masz trace’u
❌ Trudno eksportować do FE	Nie masz computedRules, tylko runtime’owy kod trudny do zserializowania
❌ Trudne testowanie regresji	Musisz testować ścieżki ręcznie lub przez snapshoty runtime



.field("fieldA")

    // 1. widoczność pola A zależy od kanału
    .property(FieldProperty.VISIBLE)
        .group(RuleGroupType.XOR)
            .rule("show if channel is NEW")
                .when(Condition.equals("ctx.channel", "NEW"))
                .then(ActionType.REPLACE, true)
        .fallback(ActionType.REPLACE, false)

    // 2. required jeśli user chce podać dane
    .validator(ValidatorType.REQUIRED)
        .activeWhen(Condition.equals("ctx.askForIdentity", true))
        .value(new StaticValue(true))

    // 3. regex zależny od typu użytkownika
    .validator(ValidatorType.REGEX)
        .valueWhen(Condition.equals("ctx.userType", "B2B"), "^[A-Z0-9]{10}$")
        .valueWhen(Condition.equals("ctx.userType", "B2C"), "^\\d{11}$")
        .fallbackValue(".*") // catch-all

.endField()

.field("fieldB")

    // 4. minValue zależne od wartości fieldA + 3
    .validator(ValidatorType.MIN_VALUE)
        .activeWhen(Condition.notEquals("fieldA", null))
        .value(
            new DerivedValue(
                new FieldReference("fieldA"),
                new ConstantOffset(3),
                Operation.ADD
            )
        )
        .fallbackValue(new StaticValue(0))

.endField()